# 工厂方法模式(Factory Method)

## 原理
与简单工厂模式不同的是，工厂方法的创建对象过程并不是集合在一个类，而是通过抽象接口，然后子类实现接口来做到对象的创建延迟到子类，根据子类的工厂方法来创建不同的具体子类。有新的工厂子类需要
创建的时候，直接实现接口，增加新的类就可以了。

## 为何
首先，简单工厂模式是有弊端的，因为全部子类的创建接口都是集合在一个类的，如果新增子类的创建，那么就会在这个类中修改代码，这样就违背了开放闭合原则。而且在子类的创建类型越来越多的情况下，
简单工厂类的逻辑越来越臃肿，不利于代码的维护。

因此，工厂方法模式的出现可以解决以上的问题。


## 适用场景
- 子类的创建延迟到工厂子类中，各自互不影响，适用于工厂子类众多的情况
- 当一个类不知道它所需要的对象的类时，在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可
- 当一个类希望通过其子类来指定创建对象时，在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的**多态性**和**里氏代换原则**，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中

## 例子
玩具工厂生产产品
- IToy（玩具接口）
- ToyA（玩具A）
- ToyB（玩具B）
- ToyC（玩具C）
- IToyFactory(工厂接口)
- ToyFactoryA（玩具A工厂）
- ToyFactoryB（玩具B工厂）
- ToyFactoryC（玩具C工厂）

缺点
- 添加新产品时，除了增加新产品类外，还需对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度
- 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类
- 一个具体工厂只能创建一种具体产品